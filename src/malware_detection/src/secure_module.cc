#include "malware_detection/src/secure_module.hh"

#include <iostream>

#include "base/trace.hh"
#include "debug/SecureModule.hh"
#include "debug/SecureModuleCpp.hh"
#include "debug/SecureModuleCycles.hh"

namespace gem5
{

  // constructor
  SecureModule::SecureModule(const SecureModuleParams &params)
      : ClockedObject(params), waitingPortId(-1),
        cpuPort(params.name + ".cpu_side", this),
        memPort(params.name + ".mem_side", this),
        mem_issue_latency(params.mem_issue_latency),
        read_issue_latency(params.read_issue_latency),
        write_issue_latency(params.write_issue_latency),
        dram_avg_access_latency(params.dram_avg_access_latency),
        blocked(false),
        responseQueue(params.response_queue_size),
        requestQueue(params.request_queue_size)
  // requestQueue(params.queue_size),
  {
    pendingRequest = false;
    pendingResponse = false;

    cpuWaiting = false;
    cpuBlocked = false;
    memBlocked = false;
    std::srand(0);
  }

  void SecureModule::startup()
  {
    DPRINTF(SecureModuleCpp, "startup\n");
    schedule(new EventFunctionWrapper([this]
                                      { cycle(); },
                                      name() + ".startupEvent", true),
             clockEdge(Cycles(1)));
  }

  // on every cycle, we check if we have any packets to send to the cpu or memory
  void SecureModule::cycle()
  {
    // print size of both queues and pending flags, all in one line
    DPRINTF(SecureModuleCycles, "requestQueue.size: %d, responseQueue.size: %d, pendingRequest: %d, pendingResponse: %d\n", requestQueue.size(), responseQueue.size(), pendingRequest, pendingResponse);

    if (!requestQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "requestQueue.front() is ready\n");
      memPort.sendPacketQueue();
    }
    // try to send repsonses
    if (!responseQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "repsponseQueue.front() is ready\n");
      cpuPort.sendPacketQueue();
    }

    // other things that should just happen every cycle
    handleCpuReqRetry();
    handleMemRespRetry();

    // invoke on the next cycle, keep this going.
    // do we need to make sure this stops at some point?
    schedule(new EventFunctionWrapper([this]
                                      { cycle(); },
                                      name() + ".startupEvent", true),
             clockEdge(Cycles(1)));
  }

  Port &SecureModule::getPort(const std::string &if_name, PortID idx)
  {
    DPRINTF(SecureModuleCpp, "getPort %s\n", if_name);

    if (if_name == "mem_side")
    {
      return memPort;
    }
    else if (if_name == "cpu_side")
    {
      return cpuPort;
    }
    else
    {
      // i don't really know what happens at this point...
      // tbd when a stack trace points here
      panic("returning neither a cpu nor mem port...");
      return ClockedObject::getPort(if_name, idx);
    }
  }

  AddrRangeList SecureModule::CPUSidePort::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    return owner->getAddrRanges();
  }

  bool SecureModule::CPUSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "Sending packet: %s\n", pkt->print());

    bool success = sendTimingResp(pkt);
    return success;
  }

  bool SecureModule::CPUSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    DPRINTF(SecureModuleCpp, "responseQueue.size: %d\n", owner->responseQueue.size());

    if (owner->cpuBlocked)
    {
      DPRINTF(SecureModuleCpp, "⚠️ CPU is blocked. Need to wait for a retry before attempting\n");
      return false;
    }
    if (owner->responseQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "⚠️ responseQueue is empty. nothing to send\n");
      return false;
    }

    PacketPtr pkt = owner->responseQueue.front();
    DPRINTF(SecureModuleCpp, "Sending packet: %s\n", pkt->print());
    bool succ = sendTimingResp(pkt);
    if (!succ) // return false, retry request will come later
    {
      DPRINTF(SecureModuleCpp, "❌ CPU denied packet %s\n", pkt->print());
      owner->cpuBlocked = true;
    }
    else
    { // succesful send
      owner->responseQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ CPU accepted packet %s\n", pkt->print());
    }
    return succ;
  }

  void SecureModule::CPUSidePort::recvFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "recvFunctional\n");
    // Just forward to the memobj.
    return owner->handleFunctional(pkt);
  }

  bool SecureModule::CPUSidePort::recvTimingReq(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "--> recvTimingReq, pkt-> %s\n", pkt->print());
    return owner->handleRequest(pkt);
  }

  void SecureModule::CPUSidePort::recvRespRetry()
  {
    DPRINTF(SecureModuleCpp, "recvRespRetry\n");
    owner->pendingRequest = false;
    owner->cpuBlocked = false;
  }

  // PLAN TO DEPRECATE
  bool SecureModule::MemSidePort::sendPacket(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "sendPacket\n");
    bool succ = sendTimingReq(pkt);
    if (!succ) // return false, retry request will come later
    {
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet %s", pkt->print());
    }
    else
    { // succesful send
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet %s\n", pkt->print());
    }
    return succ;
  }

  // similar to regular sendpacket, references request queue instead of a single packet
  bool SecureModule::MemSidePort::sendPacketQueue()
  {
    DPRINTF(SecureModuleCpp, "sendPacketQueue\n");
    DPRINTF(SecureModuleCpp, "requestQueue.size: %d\n", owner->requestQueue.size());

    if (owner->memBlocked)
    {
      DPRINTF(SecureModuleCpp, "Memory is blocked. Need to wait for a retry before attempting\n");
      return false;
    }
    if (owner->requestQueue.empty())
    {
      DPRINTF(SecureModuleCpp, "⚠️ requestQueue is empty. nothing to send\n");
      return false;
    }

    // PacketPtr pkt = owner->requestQueue.front();
    bool succ = sendTimingReq(owner->requestQueue.front());
    if (!succ) // return false, retry request will come later
    {
      DPRINTF(SecureModuleCpp, "memory denied packet, entering state MEM_WAITING_RETRY\n");
      DPRINTF(SecureModuleCpp, "❌ Memory denied packet\n");
      owner->memBlocked = true;
    }
    else
    { // succesful send
      owner->requestQueue.pop();
      DPRINTF(SecureModuleCpp, "✅ Memory accepted packet\n");
    }
    return succ;
  }

  bool SecureModule::MemSidePort::recvTimingResp(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "<-- recvTimingResp\n");
    return owner->handleResponse(pkt);
  }

  void SecureModule::MemSidePort::recvReqRetry()
  {
    DPRINTF(SecureModuleCpp, "recvReqRetry\n");
    owner->pendingResponse = false;
    owner->memBlocked = false;
    sendPacketQueue();
  }

  void SecureModule::MemSidePort::recvRangeChange()
  {
    DPRINTF(SecureModuleCpp, "recvRangeChange\n");
    owner->sendRangeChange();
  }

  // secure module main methods
  void SecureModule::handleCpuReqRetry()
  {
    if (pendingRequest)
    {
      DPRINTF(SecureModuleCpp, "Sending CPU request retry\n");
      pendingRequest = false;
      cpuPort.sendRetryReq();
      return;
    }
  }

  void SecureModule::handleMemRespRetry()
  {
    if (pendingResponse)
    {
      DPRINTF(SecureModuleCpp, "Sending MEM response retry\n");
      pendingResponse = false;
      memPort.sendRetryResp();
      return;
    }
  }

  bool SecureModule::handleRequest(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "%s for addr %#x\n", pkt->cmdString(), pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleRequest . pkt: %s\n", pkt->print());
    // DPRINTF(SecureModuleCpp, "Module State: %d\n", state);
    // DPRINTF(SecureModuleCpp, "needsResponse: %d\n", pkt->needsResponse());

    Tick read_delay = clockEdge(mem_issue_latency + read_issue_latency + static_cast<Cycles>(1));
    Tick write_delay = clockEdge(mem_issue_latency + write_issue_latency + static_cast<Cycles>(1));
    Tick delay = 0;

    // just push the packet for now. don't block
    // requestQueue.push(pkt);
    // return true;

    if (requestQueue.full())
    {
      DPRINTF(SecureModuleCpp, "Request queue is full. Denying request\n");
      pendingRequest = true;
      return false;
    }
    else
    {
      if (pkt->isRead())
      {
        DPRINTF(SecureModuleCpp, "Read req: scheduling for tick %d\n", read_delay);
        delay = read_delay;
      }
      else if (pkt->isWrite())
      {
        DPRINTF(SecureModuleCpp, "Write req: scheduling for tick %d\n", write_delay);
        delay = write_delay;
      }
      else
      {
        fatal("Unknown packet type: %s\n", pkt->cmdString());
      }
      schedule(new EventFunctionWrapper([this, pkt]
                                        { enqueueRequest(pkt); },
                                        name() + ".accessEvent", true),
               delay);
    }

    return true;
  }

  bool SecureModule::handleResponse(PacketPtr pkt)
  {
    DPRINTF(SecureModule, "Got response for addr %#x\n", pkt->getAddr());
    DPRINTF(SecureModuleCpp, "handleResponse. pkt-type: %s\n", pkt->cmdString());

    // we got here because memPort.recvTimingResp was called.
    // either we succesfully add pkt to respons queue or we return false to sender
    // and ask for a retry later when we're ready
    bool succ = responseQueue.push(pkt);
    if (!succ)
    {
      DPRINTF(SecureModuleCpp, "enqueueResponse failed\n");
      pendingResponse = true;
    }
    else
    {
      pendingResponse = false; // by virtue of the queue having space
      DPRINTF(SecureModuleCpp, "enqueueResponse success\n");
    }
    return succ;
  }

  void SecureModule::setPacketReady(bool *b)
  {
  }

  void SecureModule::unBlock(PacketPtr pkt)
  {
  }

  // do we need these?
  bool SecureModule::enqueueRequest(PacketPtr pkt)
  {
    if (requestQueue.push(pkt))
    {
      DPRINTF(SecureModuleCpp, "enqueueRequest success\n");
      return true;
    }
    else
    {
      DPRINTF(SecureModuleCpp, "enqueueRequest failed\n");
      return false;
    }
  }

  bool SecureModule::enqueueResponse(PacketPtr pkt)
  {
  }

  void SecureModule::cleanReady()
  {
    DPRINTF(SecureModuleCpp, "cleanReady\n");
    // should not execute here if we are not in the ready state
    if (cpuWaiting)
    {
      DPRINTF(SecureModuleCpp, "sendingRetyReq\n");
      cpuPort.sendRetryReq();
    }
  }

  void SecureModule::handleFunctional(PacketPtr pkt)
  {
    // DPRINTF(SecureModuleCpp, "handleFunctional\n");
    // Just pass this on to the memory side to handle for now.
    memPort.sendFunctional(pkt);
  }

  AddrRangeList SecureModule::getAddrRanges() const
  {
    DPRINTF(SecureModuleCpp, "getAddrRanges\n");
    DPRINTF(SecureModule, "Sending new ranges\n");
    // Just use the same ranges as whatever is on the memory side.
    return memPort.getAddrRanges();
  }

  void SecureModule::sendRangeChange()
  {
    DPRINTF(SecureModuleCpp, "sendRangeChange\n");
    cpuPort.sendRangeChange();
    // for (auto &port : cpuPorts) {
    //   port.sendRangeChange();
    // }
  }
  // atomics
  Tick SecureModule::CPUSidePort::recvAtomic(PacketPtr pkt)
  {
    DPRINTF(SecureModuleCpp, "recvAtomic\n");
    Tick tick = owner->memPort.sendAtomic(pkt);
    return tick;
  }

} // namespace gem5
